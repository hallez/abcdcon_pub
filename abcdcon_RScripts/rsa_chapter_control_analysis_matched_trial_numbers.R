#' ---
#' title: ABCDCon Matched Trial Numbers
#' author: Halle R. Dimsdale-Zucker
#' output:
#'  html_document:
#'    toc: true
#'    toc_depth: 4
#'    toc_float:
#'      collapsed: false
#'      smooth_scroll: false
#'    number_sections: true
#'    theme: spacelab
#' ---

#+ initialize, warning = FALSE, message = FALSE
devtools::load_all()

# add dplyr with library()
# NB: this is non-standard
# correct way would be to make this script into a function,
# store in the R/ directory,
# and use @importFrom dplyr "%>%",
# but this is incompatible with getting in-line results with code in knitr output
library(dplyr)

#' # Setup
#' ## Load config file
project_dir <- ("../")
config <- yaml::yaml.load_file(paste0(project_dir, "config.yml"))

#' ## Set paths as variables
analyzed_mri_dir <- paste0(project_dir,halle::ensure_trailing_slash(config$directories$analyzed_mri))
graph_fpath_out <- halle::ensure_trailing_slash(file.path("/Users", "hrzucker", "Dropbox", "work", "manuscripts", "rsa-methods-chapter", "figures"))

#' ## Setup other variables
#' ### Flags
SAVE_GRAPHS_FLAG <- 1
REGENERATE_FLAG <- 0

#+ label="Load data"
#' ## Load in PS data
# these dataframes are generated by `mixed_models.R`
load(paste0(analyzed_mri_dir, 'group_z_renamed_spatial_temporal_PS_by_trial.RData'))

#' ## List included subjects
unique(all_trials_z_better_names$subj)

if(REGENERATE_FLAG != 1){
  print('Loading existing file with reduced trials.')
  load(paste0(analyzed_mri_dir, sprintf('match_trialnums_rsa_chapter.RData')))
} else if(REGENERATE_FLAG == 1){
  print('Generating a new set of reduced trials.')
  #' # Calculate trial numbers per subject per condition
  min_trial_nums_by_subj <- all_trials_z_better_names %>%
    dplyr::filter(roi %in% c("CA1_body", "CA2_3_DG_body")) %>%
    # do this so doesn't aggregate across ROIs, but should have same number of trials in each ROI
    dplyr::group_by(subj, condition, roi, hemi) %>%
    dplyr::summarise(trial_nums = n()) %>% # could also do as length(<some-column>)
    dplyr::group_by(subj) %>%
    # it's ok that this just pulls a single ROI
    dplyr::slice(which.min(trial_nums)) # http://stackoverflow.com/questions/21308436/dplyr-filter-get-rows-with-minimum-of-variable-but-only-the-first-if-multiple

  #' # Generate a random index the lenght of the minimum number of trials per subject
  rois_of_interest <- c("CA1_body", "CA2_3_DG_body")
  hemi_of_interest <- c("left", "right")
  # include all conditions of interest even though minimum number of trials is defined by `sameVideo_sameHouse`
  conditions_of_interest <- c("diffVideo_diffHouse", "diffVideo_sameHouse", "sameVideo_sameHouse")
  group_subset <- data.frame()

  #' # Loop across subjects and randomly resample
  for(isubj in 1:length(unique(all_trials_z_better_names$subj))){
    cur_subj <- unique(all_trials_z_better_names$subj)[isubj]

    # figure out current minimum number of trials
    cur_min <- min_trial_nums_by_subj %>%
      dplyr::ungroup() %>%
      dplyr::filter(subj == cur_subj)
    print(sprintf("Current minimum number of trials is %d for %s./n", cur_min$trial_nums, cur_subj))

    for(iroi in 1:length(rois_of_interest)){
      cur_roi <- rois_of_interest[iroi]
      print(cur_roi)

      for(ihemi in 1:length(hemi_of_interest)){
        cur_hemi <- hemi_of_interest[ihemi]
        print(cur_hemi)

        for(icond in 1:length(conditions_of_interest)){
          cur_cond <- conditions_of_interest[icond]
          print(cur_cond)

          # subset df
          cur_dat <- all_trials_z_better_names %>%
            dplyr::filter(subj == cur_subj) %>%
            dplyr::filter(roi == cur_roi) %>%
            dplyr::filter(hemi == cur_hemi) %>%
            dplyr::filter(condition == cur_cond) %>%
            dplyr::mutate(rowids = attr(., "row.names")) #this returns integers instead of characters

          # generate random sequence
          cur_rand <- sample(seq(from = 1, to = dim(cur_dat)[1]), size = cur_min$trial_nums, replace = FALSE) %>%
            as.data.frame() %>%
            setNames("rowids") %>%
            dplyr::arrange(rowids)

          # index current df by random sequence
          # based on http://stackoverflow.com/questions/21916354/subsetting-by-multi-column-index-key-in-dplyr-have-data-table-soln
          cur_subset <-
            dplyr::semi_join(cur_dat, cur_rand, by = "rowids")

          # merge into group df
          if(dim(group_subset)[1]==0){
            group_subset <- cur_subset
          } else {
            group_subset <- dplyr::full_join(group_subset, cur_subset, by = intersect(colnames(group_subset), colnames(cur_subset)))
          }

        } #icond
      } #ihemi
    } #iroi
  } #isubj
  save(group_subset, file = paste0(analyzed_mri_dir, sprintf('match_trialnums_rsa_chapter.RData')))
} #if(REGENERATE_FLAG


#' # Graph
#+ echo = FALSE
#' ## Graphing function
graph_PS <- function(data_in) {
  data_in %>%
    dplyr::filter(condition != "anyVideo_sameHouse") %>%
    dplyr::filter(hemi == "left") %>%
    dplyr::filter(roi %in% c("CA1_body", "CA2_3_DG_body")) %>%
    dplyr::group_by(roi, hemi, condition) %>%
    dplyr::summarise(mean = mean(r),
                     sd = sd(r),
                     n = length(r),
                     sem = sd(r)/sqrt(length(r))) %>%
    # re-order conditions
    dplyr::mutate(condition_ordered = factor(condition, levels = c("sameVideo_sameHouse", "diffVideo_sameHouse", "diffVideo_diffHouse"))) %>%
    # put one space between same/diff and video/house and TWO spaces between where we'll want a line break
    # this will help `gsub` only create 2 lines for each condition name rather than 4 lines
    dplyr::mutate(condition_renamed = car::recode(condition_ordered, "'diffVideo_sameHouse' = 'Different Video  Same House'; 'diffVideo_diffHouse' = 'Different Video  Different House' ; 'sameVideo_sameHouse' = 'Same Video  Same House'")) %>%
    dplyr::mutate(condition_renamed_ordered = factor(condition_renamed, levels = c("Same Video  Same House", "Different Video  Same House", "Different Video  Different House"))) %>%
    # based on https://www.r-bloggers.com/line-breaks-between-words-in-axis-labels-in-ggplot-in-r/
    dplyr::mutate(condition_breaks = gsub("  ", "\n", condition_renamed_ordered)) %>%
    ggplot2::ggplot(ggplot2::aes(x = condition_breaks, y = mean, fill = condition_breaks)) +
    ggplot2::geom_bar(stat = "identity") +
    ggplot2::facet_grid(. ~ roi) +
    # to match colors from method figure:
    # "#CC6633" = orange (diff video, diff house)
    # "#CC6699" = fuscia (same video, same house)
    # "#66CC33" = green (different video, same house)
    ggplot2::scale_fill_manual(values = c("#CC6633", "#66CC33", "#CC6699")) +
    ggplot2::geom_errorbar(ggplot2::aes(ymax = mean + sem,
                                        ymin = mean - sem,
                                        width=0.10)) +
    ggplot2::ggtitle("Neural pattern similarity for spatial and event contexts") +
    ggplot2::ylab("Mean Pattern Similarity (r)") +
    ggplot2::theme(axis.text.x = ggplot2::element_text(size = 10, color = "black"), axis.title.x = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_text(size = 20),
                   axis.text.y = ggplot2::element_text(size = 10), axis.title.y = ggplot2::element_text(size = 20),
                   strip.text.y = ggplot2::element_text(size = 20),
                   legend.title = ggplot2::element_blank(), legend.text = ggplot2::element_blank(),
                   plot.title = ggplot2::element_text(size=20, vjust=2)) +
    ggplot2::theme(legend.position = "none")

}

#' ## Graph subset trials
group_subset %>%
  graph_PS(.)

ggplot2::ggsave(file = paste0(graph_fpath_out,
                              "sameAll_sameSome_diffAll_left_body_CA1_CA23DG_matched_trial_nums.pdf"),
                width=8, height=6)

#' ## Graph all trials
all_trials_z_better_names %>%
  graph_PS(.)

ggplot2::ggsave(file = paste0(graph_fpath_out,
                              "sameAll_sameSome_diffAll_left_body_CA1_CA23DG_all_trials.pdf"),
                width=8, height=6)
